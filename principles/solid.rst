`SOLID`--
=========

S) Single-responsibility principle / Принцип единственной ответственности
-

Каждый объект, класс и метод должны отвечать только за что-то одно.
Если объект/класс/метод делает слишком много, выходит спагетти-код. Вот пример:

Code
----

const saveTodo = async () => {
    try {
        response = await saveTodoApi();
        showSuccessPop('Success');
        window.location.href = '/successPage';
    } catch (error) {
        showErrorPopup(`Error: ${error} `);
    }
}

Этот метод кажется безобидным, но на самом деле он делает слишком много:

Сохраняет объект
Обрабатывает уведомление в UI
Выполняет навигацию

Еще один побочный эффект такого кода – проблемы с тестированием.
Запутанный функционал тестировать сложно.

O) Open–closed principle / Принцип открытости-закрытости
-

Программные объекты должны быть открыты для расширения, но закрыты для модификации.
Речь о том, что нельзя переопределять методы или классы,
просто добавляя дополнительные функции по мере необходимости.

L) Liskov substitution principle / Принцип подстановки Лисков
-

Функции, которые используют базовый тип,
должны иметь возможность использовать подтипы базового типа, не зная об этом.

I) Interface segregation principle / Принцип разделения интерфейсов
-

Объекты не должны зависеть от интерфейсов, которые они не используют.

D) Dependency inversion principle / Принцип инверсии зависимостей
-

Зависимости должны проявляться через абстракции, а не через конкретные реализации.
То есть через интерфейсы, а не классы.
Компоненты ПО должны иметь низкую связность и высокую согласованность.
Заботиться нужно не о том, как что-то устроено, а о том, как оно работает.

https://habr.com/ru/company/itelma/blog/546372/
